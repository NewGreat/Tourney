\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{tabto}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{eurosym}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\usepackage{tikz}
\usepackage{graphicx}

\newcommand{\umlbullet}[1] {
	\raisebox{0.5ex}{
	\begin{tikzpicture}[#1]
		\draw (1ex,0.4ex) -- (1ex,1.3ex);
		\draw (1ex,0.4ex) -- (2ex,0.4ex);
	\end{tikzpicture}}
}

\usepackage{enumitem}
\newlist{umlscheme}{itemize}{7}
\setlist[umlscheme]{label=\umlbullet{}}
\setlist[umlscheme,1]{parsep=-5pt}
\setlist[umlscheme,2]{parsep=-5pt}
\setlist[umlscheme,3]{parsep=-5pt}
\setlist[umlscheme,4]{parsep=-5pt}
\setlist[umlscheme,5]{parsep=-5pt}
\setlist[umlscheme,6]{parsep=-5pt}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\}

\newcommand{\includediagram}[2]{
	\begin{center}
		\includegraphics[width=#1\textwidth]{#2}
	\end{center}
}

\renewcommand{\contentsname}{Inhaltsverzeichnis}

\begin{document}

\begin{titlepage}
	\begin{center}
		\vspace*{1cm}

		\Huge
		\textbf{Tourney}\\
		Entwurf

		\vspace{0.5cm}
		\LARGE
		Softwarepraktikum\\
		\Large
		Wintersemester 2014/2015

		\vspace{1.5cm}

		\large
		\textbf{Jonas Auer (2860992)\\
				 Fabian Biester (2859084)\\
				 Jan Tagscherer (2893134)}

		\vfill

		\includegraphics[width=0.4\textwidth]{../Logo.png}

		\vspace{1.5cm}

		\Large
		Universität Stuttgart\\
		12.12.2014
	\end{center}
\end{titlepage}

\newpage

\tableofcontents

\section{Einleitung}

Dieser Entwurf bietet den Entwicklern von \textbf{Tourney} einen Überblick über die Architektur der Software. Dadurch wird ein Grundgerüst bereitgestellt, das die geplante Implementierung ermöglicht.

\subsection{Zweck des Software-Systems}

In diesem Entwurf wird die Architektur von \textbf{Tourney} beschrieben. Dabei handelt es sich um Software, die die bisher händisch erfolgte Organisation von Spielturnieren des Heidelberger Spieleverlags übernehmen und vereinfachen soll. Dazu soll das Programm die Organisatoren durch den kompletten Prozess der Turnierplanung begleiten und sie bei den typischen Aufgaben wie der Teilnehmerverwaltung und der eigentlichen Durchführung der Turniere unterstützen.

Besonderer Wert wird hierbei auf eine intuitive Bedienung gelegt, die mit möglichst wenig Aufwand zum Ziel führt.

\subsection{Leserkreis des Entwurfs}

Zum Leserkreis dieses Entwurfsdokuments gehören die folgenden Personengruppen:
\begin{itemize}
	\item Die Entwickler der Software
	\item Die für die Wartung oder Weiterentwicklung zuständigen Software-Ingenieure
	\item Die Betreuer
\end{itemize}

\subsection{Angewandte Entwicklungsprinzipien}

Der Entwurf von \textbf{Tourney} findet im Top-Down-Prinzip statt. Hierzu wird die geforderte Gesamtfunktionalität des Systems betrachtet und dann zur Erfüllung dieser notwendige Aufgaben auf Komponenten und schließlich Klassen verteilt.

\subsection{Überblick über den Entwurf}

Das Entwurfsdokument wird in die folgenden Kapitel gegliedert:
\begin{itemize}
	\item[] \textbf{Kapitel 1} gibt einen groben Überblick über das zu entwickelnde Softwaresystem und das hierzu erstellte Entwurfsdokument.
	\item[] \textbf{Kapitel 2} umfasst die Architektur, die die Software in überschaubare Komponenten gliedert. Diese werden dazu in einem Komponentendiagramm dargestellt.
	\item[] \textbf{Kapitel 3} beschreibt die in der Architektur definierten Komponenten je nach Bedarf über Klassendiagramme zur Schnittstelle, Sequenzdiagramme zum Protokoll und Zustands- und Aktivitätsdiagrammen zum Verhalten im Detail.
	\item[] \textbf{Kapitel 4} charakterisiert externe Schnittstellen und die verwendete Methodik zur persistenten Datenspeicherung.
	\item[] \textbf{Kapitel 5} enthält die Versionshistorie zu diesem Dokument.
\end{itemize}

\section{Architektur des Systems}

\subsection{Überblick über die Architektur}

Das geplante System wird in einer klassischen Architektur aus drei Schichten realisiert. Hierzu findet eine Gliederung in die drei Komponenten Benutzeroberfläche, Anwendungslogik und Datenhaltung statt. Da die Benutzeroberfläche über \textit{JavaFX} erstellt wird ist diese standardmäßig in externe \textit{.fxml}-Dateien ausgelagert. Die Anwendungslogik dient als Vermittler zwischen den anderen beiden Komponenten und reagiert auf Eingaben aus der Benutzeroberfläche mit den richtigen Operationen auf der Datenhaltungsschicht.

Bei der Architektur wird Wert auf eine geringe Kopplung zwischen und einen hohen Zusammenhalt in den Modulen gelegt. Dies wird unter anderem durch das Verwenden von \textit{JavaFX-Bindings} gewährleistet. Hierbei werden Attribute von Klassen mit anderen Attributen oder Elementen der Benutzeroberfläche über eine Listener-Architektur gebunden und bei Bedarf neu berechnet oder aktualisiert.

\subsection{Verwendete Entwurfsmuster}

Bei der Entwicklung werden an einigen Stellen die folgenden bewährten Entwurfsmuster verwendet:
\begin{itemize}
	\item[] \textbf{Observer} \hfill
	
	\leftskip 1cm
	Ändern sich die Attribute von Objekten, so müssen häufig sowohl die Benutzer-oberfläche aktualisiert als auch andere Attribute neu berechnet werden. In entgegengesetzter Richtung ändern einige Eingaben über die Benutzeroberfläche Attribute.
	
	Dieser Zusammenhang wird über \textit{JavaFX-Bindings} implementiert, wobei das Observer-Entwurfsmuster verwendet wird. Hierzu werden alle relevanten Attribute als \textit{JavaFX-Properties} deklariert.

	\leftskip 0cm
	\item[] \textbf{Strategy} \hfill
	
	\leftskip 1cm
	Die Berechnung der Ergebnisse von Spielrunden findet immer abhängig von dem verwendeten Regelmodul statt. Dazu wird jedes mögliche Paarungsprinzip als Subklasse einer Strategie-Oberklasse hinzugefügt und kann austauschend verwendet werden. Diese Modularität trägt zur guten Erweiterbarkeit bei.
	
	\leftskip 0cm
	\item[] \textbf{Singleton} \hfill
	
	\leftskip 1cm
	Die Klasse \textit{PreferencesManager} zur Verwaltung der Einstellungen darf pro laufendem System nur als eine Instanz vorhanden sein. Daher wird das Entwurfsmuster des Singletons verwendet.
\end{itemize}

\subsection{Komponentendiagramm}

\includediagram{0.7}{component-diagram.png}

\section{Komponenten}

\subsection{Model}

Im folgenden wird die Schicht der Datenhaltung und Anwendungslogik beschrieben und strukturiert.

\subsubsection{Klassendiagramme}

\includediagram{1.0}{model-main.png}

\includediagram{1.0}{model-undo.png}

\subsubsection{Beschreibung}
Zu Anfangs steht die Klasse \textit{Event} sie symbolisiert das echte Event, sie enthält die Spielerliste und die Tournierliste. In der Klasse \textit{Turnier} läuft das Turnier ab, es werden die Teilnehmden \textit{Spieler} gespeichert und die bisherigen Runden und deren Ergebnisse. In der Klasse \textit{Spieler} werden die persönlichen Daten des Spieler, wie Vorname, Nachname und Mail Adresse gespeichert. Die Klassen sind reine Datenstrukturen, jegliche Logik wird in den \textit{Controllern} ausgeführt.\\
Der \textit{UndoManager} bietet eine einfach zu benutzende Schnittstelle, um es dem Benutzer zu ermöglichen, durchgeführte Aktionen wieder rückgängig zu machen. Dieses Verfahren lässt sich auf alle \textit{JavaFX-Properties} und \textit{JavaFX-Listen} anwenden, indem man sie durch \textit{registerUndoProperty()} registriert.\\
Intern werden alle an den Properties gemachten Änderungen in einer verketteten Liste gespeichert, die aus \textit{UndoNode}s aufgebaut ist.\\
Die ausgeführten Änderungen werden innerhalb der Nodes als konkrete Implementierung des \textit{UndoAction} Interfaces abgelegt, das die beiden Methoden \textit{undo()} und \textit{redo()} bereitstellt. Die Implementierungen kümmern sich dann um die konkrete Ausführung der Rückgängig- und Wiederherstell-Aktionen.\\
Wenn an \textit{JavaFX-Properties} Änderungen erfolgen, werden diese als \textit{PropertyUndoAction} gespeichert. Der vorherige und der neue Wert werden gespeichert, um später rückgängig gemacht oder wiederhergestellt werden zu können.
Änderungen an \textit{JavaFX-Listen} sind von etwas komplizierterer Natur, da hier pro Change-Event mehrere Hinzufüge- und Entfernen-Aktionen zusammengefasst sind. Daher wird dieses Verhalten in einer \textit{ListUndoAction} gespiegelt, die verschiedene \textit{ListChange}s beinhaltet. Dabei entsprechen \textit{ListAddition}s dem Hinzufügen von Werten zu einer Liste und \textit{ListRemoval}s dem Entfernen von Werten von einer Liste.

\subsection{View}

Beim View handelt es sich um die eigentliche grafische Benutzeroberfläche, die über \textit{JavaFX} implementiert wird.

\subsubsection{Beschreibung}

Die Benutzeroberfläche in \textit{JavaFX} besteht aus jeweils einer \textit{.fxml}-Datei für jede in der Kontrollstruktur beschriebene Controller-Klasse. Diese Dateien enthalten XML-strukturierte Daten, die die Oberfläche jeweils eines Fensters beschreiben und die Callback-Methode bei einer durch den Nutzer initiierten Aktion festlegen.

Durch diese Strukturierung ist eine komplette Kapselung der Benutzeroberfläche mit geringer Kopplung zu den anderen Komponenten gegeben.

\subsection{Controller}

Die Kontrollstruktur nimmt Eingaben von der Benutzeroberfläche entgegen und führt anhand dessen die passenden Operationen auf der Datenhaltungsschicht aus. Die Struktur wird im Folgenden beschrieben.

\subsubsection{Klassendiagramm}

\includediagram{1.0}{controller.png}

\subsubsection{Beschreibung}

\textit{TODO: Beschreibung}

\subsection{Verbindung der Komponenten}

Die beiden Schichten View und Controller sind über eine Listener-Struktur miteinander verbunden, wobei Eingaben des Nutzers einen Callback zur Folge haben.

Die Kontrollstruktur hält für den Zugriff relevante Instanzen aus der Datenhaltungsschicht bereit.

Außerdem sind bestimmte Attribute untereinander und Elemente der Benutzeroberfläche über \textit{JavaFX-Bindings} miteinander verknüpft. Hierzu werden als Attribute an den relevanten Stellen \textit{JavaFX-Properties} verwendet.

\subsection{Sequenzdiagramme}

\subsubsection{Turniermodul hinzufügen}

\includediagram{1.0}{sequence-add-tournament-module.png}

Sendet der Administrator über die Oberfläche den Befehl an den \textit{TournamentModuleEditorController}, ein neues Regelmodul zu erstellen, so wird dieser zunächst initialisiert. Daraufhin wird eine neue Instanz der Klasse \textit{TournamentModule} erstellt und an den Controller zurückgegeben. Dieser stellt nun die Oberfläche dar, in der der Administrator das Modul editieren kann.

\subsubsection{Vorangemeldeten Spieler bestätigen}

\includediagram{1.0}{sequence-verify-registered-player.png}

Um einen vorangemeldeten Spieler durch eine Anmeldung über den \textit{RegistrationPhase-Controller} zu bestätigen holt der Controller die Liste aller registrierten und teilnehmenden Spieler vom Turnier-Objekt und kopiert den anzumeldenden Spieler in die Liste der teilnehmenden Spieler.

\subsubsection{Aktion rückgängig machen}

\includediagram{1.0}{sequence-undo-action.png}

Will ein Nutzer eine Aktion im \textit{EventPhaseViewController} rückgängig machen, so wird der zugehörige Befehl an die Instanz des \textit{UndoManagers} gesendet. Dieser holt sich die aktuelle Aktion auf der Benutzeroberfläche von der Liste von Aktionen und macht diese rückgängig. Zuletzt wird noch das Wiederherstellen dieser Aktion möglich gemacht.

\subsubsection{Passwort ändern}

\includediagram{1.0}{sequence-change-password.png}

Das Ändern des Passworts findet über einen Aufruf des \textit{OptionsViewControllers} statt. Dieser öffnet wiederum einen \textit{PasswordDialogController}, der initialisiert wird und sich dann die Singleton-Instanz vom \textit{PreferencesManager} holt. Über diese wird schließlich das neue Passwort gesetzt. Der \textit{PreferencesManager} übernimmt hierbei Operationen wie das Hashing des Passworts.

\subsubsection{Neues Event erstellen}

\includediagram{1.0}{sequence-create-event.png}

Will der Administrator ein neues Event über den \textit{MainWindowController} erstellen, so wird zunächst ein \textit{EventCreationDialog} geöffnet und initialisiert. Dieser erstellt ein neues \textit{Event}, das der \textit{MainWindowController} dann an einen \textit{EventPhaseViewController} weitergibt. Das neue Event wird schließlich in einem \textit{EventSetupPhaseController} dargestellt.

\section{Externe Schnittstellen}

\subsection{Dauerhafte Datenspeicherung}

Die Speicherung von Daten findet über das \textit{XML}-Dateiformat statt und wird von der Klasse \textit{FileManager} übernommen. Diese bietet statische Methoden, die relevante Objektgeflechte speichern und aus validen Dateien laden kann.

\subsubsection{Speicherung eines Events}

Es werden die folgenden Dateistrukturierungen verwendet und in \textit{Zip}-Dateien mit der Dateiendung \textit{.tmf} zusammengefasst. Ein solches Dateipaket beschreibt ein komplettes Event mit allen seinen Turnieren und Teilnehmern.

Je nachdem ob das komplette Event auf einem Administrationsrechner gespeichert werden soll oder ob Spielerdaten an einen weiteren Anmeldungsplatz oder Turnierdaten an den Arbeitsplatz eines Turnierordners weitergegeben oder dort gespeichert werden soll werden nur die jeweils relevanten Auszüge aus den Dateien genutzt. Zudem lässt die Software über die Benutzeroberfläche keine Änderungen an Daten zu, die ein Nicht-Administrator nicht bearbeiten darf, da diese beim Zusammenfügen am Administrationsrechner schließlich nicht beachtet werden.

\subsubsubsection{Event}

Die Datei \textit{Event.xml} speichert allgemeine Daten zum ganzen Event. Sie ist folgendermaßen strukturiert:
\vspace{0.4cm}

\fbox{\parbox{\textwidth}{
\begin{umlscheme}
	\item metadata
	\begin{umlscheme}
		\item name
		\item location
		\item date
		\begin{umlscheme}
			\item start-date
			\item end-date
		\end{umlscheme}
		\item event-administrators
		\begin{umlscheme}
			\item administrator 1
			\begin{umlscheme}
				\item name
				\begin{umlscheme}
					\item first-name
					\item last-name
				\end{umlscheme}
				\item mail-address
				\item phone-number
			\end{umlscheme}
			\item[] $\vdots$
		\end{umlscheme}
	\end{umlscheme}
	\item tournaments
	\begin{umlscheme}
		\item tournament 1
		\begin{umlscheme}
			\item id
		\end{umlscheme}
		\item[] $\vdots$
	\end{umlscheme}
\end{umlscheme}}}

\subsubsubsection{Spieler}

Die Datei \textit{Players.xml} speichert alle Spieler, die zu einem jeweiligen Event vorangemeldet oder angemeldet sind und ist folgendermaßen strukturiert:
\vspace{0.4cm}

\fbox{\parbox{\textwidth}{
\begin{umlscheme}
	\item player 1
	\begin{umlscheme}
		\item id
		\item name
		\begin{umlscheme}
			\item first-name
			\item last-name
		\end{umlscheme}
		\item mail-address
		\item nick-name
		\item starting-number
		\item payed
		\item disqualified
	\end{umlscheme}
	\item[] $\vdots$
\end{umlscheme}}}

\subsubsubsection{Turnier}

Die Dateien \textit{TournamentID.xml} speichern jeweils ein Turnier, wobei im Dateiname die eindeutige ID des Turniers angegeben ist. Dabei sind diese Dateien folgendermaßen strukturiert:
\vspace{0.4cm}

\fbox{\parbox{\textwidth}{
\begin{umlscheme}
	\item metadata
	\begin{umlscheme}
		\item name
	\end{umlscheme}
	\item tournament-administrators
	\begin{umlscheme}
		\item administrator 1
		\begin{umlscheme}
			\item name
			\begin{umlscheme}
				\item first-name
				\item last-name
			\end{umlscheme}
			\item mail-address
			\item phone-number
		\end{umlscheme}
		\item[] $\vdots$
	\end{umlscheme}
	\item registered-players
	\begin{umlscheme}
		\item player-id 1
		\item[] $\vdots$
	\end{umlscheme}
	\item attendant-players
	\begin{umlscheme}
		\item player-id 1
		\item[] $\vdots$
	\end{umlscheme}
	\item tournament-rounds
	\begin{umlscheme}
		\item tournament-round 1
		\begin{umlscheme}
			\item pairings
			\begin{umlscheme}
				\item pairing 1
				\begin{umlscheme}
					\item participants
					\begin{umlscheme}
						\item player 1
						\vspace{0.1cm}
						\item[] \umlbullet{} id
						\item[] \umlbullet{} scores
						\vspace{0.1cm}
						\item[] \hspace{0.4cm} \umlbullet{} score 1
						\item[] \hspace{0.6cm} $\vdots$
						\item[] $\vdots$
					\end{umlscheme}
				\end{umlscheme}
				\item[] $\vdots$
			\end{umlscheme}
		\end{umlscheme}
		\item[] $\vdots$
	\end{umlscheme}
	\item tournament-rules
	\begin{umlscheme}
		\item tournament-phases
		\begin{umlscheme}
			\item phase 1
			\begin{umlscheme}
				\item phase-number
				\item number-of-rounds
				\item pairing-system
				\item cutoff-player-number-after-phase
			\end{umlscheme}
			\item[] $\vdots$
		\end{umlscheme}
	\end{umlscheme}
\end{umlscheme}}}

\subsubsection{Speicherung von Regelmodulen}

Neben den Events mit Turnieren und Spielern müssen auch noch die Vorlagen für Turniermodule gespeichert werden.

\subsubsection{Regelmodul}

Die folgendermaßen strukturierte Datei \textit{RuleTemplateID.xml} speichert jeweils eine Vorlage für Turnierregeln, die zur Erstellung eines neuen Turniers verwendet werden können. Auch sie trägt eine eindeutige ID im Dateinamen.
\vspace{0.4cm}

\fbox{\parbox{\textwidth}{
\begin{umlscheme}
	\item meta-data
	\begin{umlscheme}
		\item name
		\item description
	\end{umlscheme}
	\item possible-scores
	\begin{umlscheme}
		\item score 1
		\begin{umlscheme}
			\item name
			\item points
		\end{umlscheme}
		\item[] $\vdots$
	\end{umlscheme}
	\item tournament-phases
	\begin{umlscheme}
		\item phase 1
		\begin{umlscheme}
			\item phase-number
			\item number-of-rounds
			\item pairing-system
			\item cutoff-number-after-phase
		\end{umlscheme}
		\item[] $\vdots$
	\end{umlscheme}
\end{umlscheme}}}

\subsection{Externer Zugriff}

Auf dem Gebiet des Turniermanagements wie es von \textbf{Tourney} durchgeführt wird sind keine zu bedenkenden Systeme vorhanden. Alle Eingaben finden über die Benutzeroberfläche statt und Ergebnisse werden nur direkt an den Nutzer ausgegeben. Daher erfolgt weder auf externe Daten noch auf \textbf{Tourney} von externer Seite ein Zugriff und derartige Schnittstellen müssen nicht eingeplant werden.

\section{Versionshistorie}

\begin{itemize}
	\item Version 1.0 (06.12.2014)
	\begin{itemize}
		\item Grundstruktur des Entwurfs erstellt
	\end{itemize}
	\item Version 1.1 (07.12.2014)
	\begin{itemize}
		\item Kapitel 1 hinzugefügt
	\end{itemize}
	\item Version 1.2 (10.12.2014)
	\begin{itemize}
		\item Kapitel 2 und 4 hinzugefügt
	\end{itemize}
	\item Version 1.3 (11.12.2014)
	\begin{itemize}
		\item Kapitel 3 hinzugefügt
	\end{itemize}
\end{itemize}

\end{document}